Vue是数据驱动的，也就是说当数据发生变化，dom就会重绘。

今天在做公司项目的时候，侦听了属性zoom,本来想zoom的值发生变化，就重新绘制canvas中的点。我在一个方法中用一个循环来不停的修改zoom值，我以为每个循环这个zoom值的变化会触发侦听器中重绘的操作，但结果并不是预想的那样，`重绘的方法只会在循环结束后调用一次`，于是，我写了一个小实例，我发现`不仅仅是侦听属性，只要用循环不断的修改data中的数据,dom也并不是每次都重绘，而是只会重绘最后一次`，这应该是vue关于性能方面的考虑.

[小实例](https://github.com/AILINGANGEL/VuePractice/blob/master/Watch.html)


这次有遇到了一个类似的问题，就是在Safari下用鼠标滚轮来操作图像以及图像上点的变化，会很快复现图片和相关的标注点变化不一致的情况。经过反复debug,返现是因为点的变化会比图像的变化少执行。 代码中图像的缩放是通过zoom来控制的,zoom = 1 * factor * factor，而点的变化是用过factor来计算的。通过查阅vue的文档，发现有下面这句话:

```
可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。
```

safari和chrome虽然内核一样都是webkit但是Js引擎却是不一样的,对鼠标滚轮事件更明锐,当滚轮滑动过快时,zoom值变化的太快，这个时候就会像上面文档中说的那样,侦听器里面的函数会放在下一个事件循环中.但是图像的大小是使用计算属性得到的，可以得到正确的值,而点的变化却没有执行,只有在下一个事件讯中中进行一次乘以或者除以factor的操作.这个时候显然就和图像使用zoom变化不一致了.


[参考这里的官方文档](https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97)