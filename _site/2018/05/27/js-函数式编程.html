<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>[js]函数式编程 | 小飞侠的博客</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="[js]函数式编程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="函数式编程 1.什么是函数式编程 函数式编程是通过复合春函数来构建软件的过程,它避免了共享的状态，易变的数据以及副作用。函数式编程是声明式而不是命令式,并且应用程序状态通过纯函数流转。对比面向对象编程，后者的应用程序状态是共享并共用于对象方法。" />
<meta property="og:description" content="函数式编程 1.什么是函数式编程 函数式编程是通过复合春函数来构建软件的过程,它避免了共享的状态，易变的数据以及副作用。函数式编程是声明式而不是命令式,并且应用程序状态通过纯函数流转。对比面向对象编程，后者的应用程序状态是共享并共用于对象方法。" />
<link rel="canonical" href="http://localhost:4000/2018/05/27/js-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" />
<meta property="og:url" content="http://localhost:4000/2018/05/27/js-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html" />
<meta property="og:site_name" content="小飞侠的博客" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-27T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"函数式编程 1.什么是函数式编程 函数式编程是通过复合春函数来构建软件的过程,它避免了共享的状态，易变的数据以及副作用。函数式编程是声明式而不是命令式,并且应用程序状态通过纯函数流转。对比面向对象编程，后者的应用程序状态是共享并共用于对象方法。","@type":"BlogPosting","url":"http://localhost:4000/2018/05/27/js-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html","headline":"[js]函数式编程","dateModified":"2018-05-27T00:00:00+08:00","datePublished":"2018-05-27T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/05/27/js-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=488ca3eca1344e8385010f50d5f32e887f7b82a5">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">小飞侠的博客</h1>
        <p class="header">一个女码农的自我修养</p>

        <ul>
          
          <li><a class="buttons github" href="http://github.com/AILINGANGEL/AILINGANGEL.github.io">View On GitHub</a></li>
        </ul>

        
          <p class="header">This project is maintained by <a class="header name" href="http://github.com/AILINGANGEL">AILINGANGEL</a></p>
        

        
      </header>

      <section>
        <h1 id="函数式编程">函数式编程</h1>
<h2 id="1什么是函数式编程">1.什么是函数式编程</h2>
<p>函数式编程是通过复合春函数来构建软件的过程,它避免了共享的状态，易变的数据以及副作用。函数式编程是<code class="highlighter-rouge">声明式</code>而不是<code class="highlighter-rouge">命令式</code>,并且应用程序状态通过纯函数流转。对比面向对象编程，后者的应用程序状态是共享并共用于对象方法。</p>

<p>函数式编程的核心概念:</p>

<ul>
  <li>纯函数</li>
  <li>函数复合</li>
  <li>避免共享状态</li>
  <li>避免改变状态</li>
  <li>避免副作用</li>
</ul>

<h3 id="纯函数">纯函数</h3>
<blockquote>
  <p>给它同样的输入，总是返回同样的结果，并且没有副作用</p>
</blockquote>

<h3 id="函数复合">函数复合</h3>
<blockquote>
  <p>函数复合是结合两个或者多个函数，从而产生一个新函数或进行某些计算的过程。例如,复合操作f·g在javasrcipt中相当于执行f(g(x))。</p>
</blockquote>

<h3 id="共享状态">共享状态</h3>
<blockquote>
  <ul>
    <li>共享状态是任意变量,对象或者内存空间存在于共享作用域下,或者作为对象的属性在各个作用域之间被传递。共享作用域包括全局作用域和闭包作用域。通常，在面向对象编程中，对象以添加属性到其他对象上的方式在作用域之间共享。</li>
    <li>举个例子，一个电脑游戏可能会控制一个游戏对象（game object），它上面有角色(characters)和游戏道具（items），这些数据作为属性存储在游戏对象之上。而函数式编程避免共享状态 —— 与前者不同地，<code class="highlighter-rouge">它依赖于不可变数据结构和纯粹的计算过程来从已存在的数据中派生出新的数据</code>。</li>
    <li>共享状态的问题是为了理解函数的作用，你需要了解那个函数所用到的全部共享变量的变化历史。</li>
    <li>共享状态的另一个常见问题是改变函数调用次序可能导致一连串的错误，因为函数操作共享数据是依时序的</li>
  </ul>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用共享数据，函数调用的次序会改变函数调用的结果</span>
<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">val</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">x1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">val</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">x2</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">x1</span><span class="p">();</span>
<span class="nx">x2</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span> <span class="c1">// 6</span>
<span class="c1">//下面的例子与上面的相同，除了……</span>
<span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">val</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">y1</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">val</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">y2</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">val</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">// ...函数的调用次序颠倒了一下...</span>
<span class="nx">y2</span><span class="p">();</span>
<span class="nx">y1</span><span class="p">();</span>
<span class="c1">// ... 这改变了结果值:</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">val</span><span class="p">);</span> <span class="c1">// 5</span>
</code></pre></div></div>

<h3 id="不可变性">不可变性</h3>
<blockquote>
  <ul>
    <li>一个不可变的对象是指一个对象不会再它创建之后被改变,对应的，一个可变对象是指任何在创建之后可以被改变的对象</li>
    <li>不要混淆const和不可变性,const 创建一个变量绑定，让该变量不能再次被赋值, const 并不创建不可变对象。虽然不能改变绑定到这个变量名上的对象，但你仍然可以改变它的属性，所以说const的变量仍然是可变的，而不是不可变的.
不可变的对象完全不能被改变，可以通过深度冻结对象来创造一个真正不可变的值</li>
  </ul>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
  <span class="na">foo</span><span class="p">:</span> <span class="s1">'Hello'</span><span class="p">,</span>
  <span class="na">bar</span><span class="p">:</span> <span class="s1">'world'</span><span class="p">,</span>
  <span class="na">baz</span><span class="p">:</span> <span class="s1">'!'</span>
<span class="p">});</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="s1">'Goodbye'</span><span class="p">;</span>
<span class="c1">// Error: Cannot assign to read only property 'foo' of object Object</span>
<span class="err">然而冻结的对象只是表面一层不可变，例如，深层的属性还是可以被改变：</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
  <span class="na">foo</span><span class="p">:</span> <span class="p">{</span> <span class="na">greeting</span><span class="p">:</span> <span class="s1">'Hello'</span> <span class="p">},</span>
  <span class="na">bar</span><span class="p">:</span> <span class="s1">'world'</span><span class="p">,</span>
  <span class="na">baz</span><span class="p">:</span> <span class="s1">'!'</span>
<span class="p">});</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">greeting</span> <span class="o">=</span> <span class="s1">'Goodbye'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span> <span class="nx">a</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">greeting</span> <span class="p">}</span><span class="s2">, </span><span class="p">${</span> <span class="nx">a</span><span class="p">.</span><span class="nx">bar</span> <span class="p">}${</span><span class="nx">a</span><span class="p">.</span><span class="nx">baz</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="副作用">副作用</h3>
<p>副作用是值除了函数返回值以外，任何在函数调用之外观察到的应用程序状态改变，比如：</p>

<ul>
  <li>改变任何外部变量或对象属性（全局变量，或者在父级函数作用域脸上的变量）</li>
  <li>写日志</li>
  <li>在屏幕输出</li>
  <li>写文件</li>
  <li>发网络请求</li>
  <li>触发任何外部进程</li>
  <li>调用另外一个有副作用的函数</li>
</ul>

<h2 id="2通过高阶函数提高可重用性">2.通过高阶函数提高可重用性</h2>
<p>在js中,<code class="highlighter-rouge">函数是一等公民</code>, js允许使用者将函数作为数据，可以将他们赋值给变量，作为参数传递给其他函数，将他们作为返回值返回等</p>

<p>高阶函数是指以函数为参数或者以函数为返回值，或者既以函数为参数又以函数为返回值。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="kr">double</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">doubleMap</span> <span class="o">=</span> <span class="nx">numbers</span> <span class="o">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kr">double</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doubleMap</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]));</span> <span class="c1">// [ 4, 6, 8 ]</span>
</code></pre></div></div>

<h2 id="3对比生命式与命令式">3.对比生命式与命令式</h2>

<ul>
  <li>
    <p>函数式编程是一个声明式范式，意思是说程序逻辑不需要通过明确描述控制流程来表达。</p>
  </li>
  <li>
    <p>命令式 程序花费大量代码来描述用来达成期望结果的特定步骤 —— 控制流：即如何做。</p>
  </li>
  <li>
    <p>声明式 程序抽象了控制流过程，花费大量代码描述的是数据流：即做什么。</p>
  </li>
</ul>

<p>命令式：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">doubleMap</span> <span class="o">=</span> <span class="nx">numbers</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">doubled</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doubled</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">doubled</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doubleMap</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]));</span> <span class="c1">// [4, 6, 8]</span>
</code></pre></div></div>

<p>声明式：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">doubleMap</span> <span class="o">=</span> <span class="nx">numbers</span> <span class="o">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">doubleMap</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]));</span> <span class="c1">// [4, 6, 8]</span>
</code></pre></div></div>

<blockquote>
  <p>命令式 代码中频繁使用语句。语句是指一小段代码，它用来完成某个行为。通用的语句例子包括 for、if、switch、throw，等等……</p>
</blockquote>

<blockquote>
  <p>声明式 代码更多依赖表达式。表达式是指一小段代码，它用来计算某个值。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。</p>
</blockquote>

<h2 id="4结论">4.结论</h2>
<ul>
  <li>使用纯函数而不是使用共享状态和副作用</li>
  <li>让可变数据成为不可变的</li>
  <li>用函数复合替代命令控制流</li>
  <li>使用高阶函数来操作许多数据类型，创建通用、可复用功能取代只是操作集中的数据的方法。</li>
  <li>使用声明式而不是命令式代码（关注做什么，而不是如何做）</li>
  <li>使用表达式替代语句</li>
  <li>使用容器与高阶函数替代多态</li>
</ul>

      </section>

      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
